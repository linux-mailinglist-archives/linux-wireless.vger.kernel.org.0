Return-Path: <linux-wireless+bounces-1562-lists+linux-wireless=lfdr.de@vger.kernel.org>
X-Original-To: lists+linux-wireless@lfdr.de
Delivered-To: lists+linux-wireless@lfdr.de
Received: from am.mirrors.kernel.org (am.mirrors.kernel.org [IPv6:2604:1380:4601:e00::3])
	by mail.lfdr.de (Postfix) with ESMTPS id B0625826893
	for <lists+linux-wireless@lfdr.de>; Mon,  8 Jan 2024 08:29:13 +0100 (CET)
Received: from smtp.subspace.kernel.org (wormhole.subspace.kernel.org [52.25.139.140])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by am.mirrors.kernel.org (Postfix) with ESMTPS id 4D3701F21BC9
	for <lists+linux-wireless@lfdr.de>; Mon,  8 Jan 2024 07:29:13 +0000 (UTC)
Received: from localhost.localdomain (localhost.localdomain [127.0.0.1])
	by smtp.subspace.kernel.org (Postfix) with ESMTP id 977488827;
	Mon,  8 Jan 2024 07:29:08 +0000 (UTC)
X-Original-To: linux-wireless@vger.kernel.org
Received: from dmta0008-f.auone-net.jp (snd00009.auone-net.jp [111.86.247.9])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by smtp.subspace.kernel.org (Postfix) with ESMTPS id 5AD658BF6
	for <linux-wireless@vger.kernel.org>; Mon,  8 Jan 2024 07:29:04 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org; dmarc=pass (p=none dis=none) header.from=d1.dion.ne.jp
Authentication-Results: smtp.subspace.kernel.org; spf=pass smtp.mailfrom=d1.dion.ne.jp
Received: from kzhr.d1.dion.ne.jp by dmta0008.auone-net.jp with ESMTP
          id <20240108071835221.UAEY.23294.kzhr.d1.dion.ne.jp@dmta0008.auone-net.jp>;
          Mon, 8 Jan 2024 16:18:35 +0900
Date: Mon, 08 Jan 2024 16:18:34 +0900
Message-ID: <857ckk1eet.wl--xmue@d1.dion.ne.jp>
From: Kazuhiro Ito <kzhr@d1.dion.ne.jp>
To: linux-wireless@vger.kernel.org
Cc: Felix Fietkau <nbd@nbd.name>,
 Lorenzo Bianconi <lorenzo@kernel.org>,
 Ryder Lee <ryder.lee@mediatek.com>,
 Shayne Chen <shayne.chen@mediatek.com>,
 Sean Wang <sean.wang@mediatek.com>
Subject: [PATCH] wifi: mt76: Create throughput LED trigger always
User-Agent: Wanderlust/2.15.9 (Almost Unreal) SEMI-EPG/1.14.7 (Harue)
 FLIM-LB/1.14.9 (=?ISO-8859-4?Q?Goj=F2?=) APEL-LB/10.8 EasyPG/1.0.0
 Emacs/30.0.50 (x86_64-w64-mingw32) MULE/6.0 (HANACHIRUSATO)
Precedence: bulk
X-Mailing-List: linux-wireless@vger.kernel.org
List-Id: <linux-wireless.vger.kernel.org>
List-Subscribe: <mailto:linux-wireless+subscribe@vger.kernel.org>
List-Unsubscribe: <mailto:linux-wireless+unsubscribe@vger.kernel.org>
MIME-Version: 1.0 (generated by SEMI-EPG 1.14.7 - "Harue")
Content-Type: text/plain; charset=US-ASCII

There are devices which have wlan LED outside mt76. We need to enable
throughput LED trigger even if mt76's LED is disabled to make external
LED blink as if internal one.

Signed-off-by: Kazuhiro Ito <kzhr@d1.dion.ne.jp>
---
 drivers/net/wireless/mediatek/mt76/mac80211.c | 26 +++++++++++++------
 1 file changed, 18 insertions(+), 8 deletions(-)

diff --git a/drivers/net/wireless/mediatek/mt76/mac80211.c b/drivers/net/wireless/mediatek/mt76/mac80211.c
index 8a3a90d1bfac..a7bd6e24aac2 100644
--- a/drivers/net/wireless/mediatek/mt76/mac80211.c
+++ b/drivers/net/wireless/mediatek/mt76/mac80211.c
@@ -193,7 +193,15 @@ static const struct cfg80211_sar_capa mt76_sar_capa = {
 	.freq_ranges = &mt76_sar_freq_ranges[0],
 };
 
-static int mt76_led_init(struct mt76_phy *phy)
+static const char * mt76_create_tpt_led_trigger(struct ieee80211_hw * hw)
+{
+	return ieee80211_create_tpt_led_trigger(hw,
+				IEEE80211_TPT_LEDTRIG_FL_RADIO,
+				mt76_tpt_blink,
+				ARRAY_SIZE(mt76_tpt_blink));
+}
+
+static int mt76_led_init(struct mt76_phy *phy, const char *trigger)
 {
 	struct mt76_dev *dev = phy->dev;
 	struct ieee80211_hw *hw = phy->hw;
@@ -228,11 +236,7 @@ static int mt76_led_init(struct mt76_phy *phy)
 		 wiphy_name(hw->wiphy));
 
 	phy->leds.cdev.name = phy->leds.name;
-	phy->leds.cdev.default_trigger =
-		ieee80211_create_tpt_led_trigger(hw,
-					IEEE80211_TPT_LEDTRIG_FL_RADIO,
-					mt76_tpt_blink,
-					ARRAY_SIZE(mt76_tpt_blink));
+	phy->leds.cdev.default_trigger = trigger;
 
 	dev_info(dev->dev,
 		"registering led '%s'\n", phy->leds.name);
@@ -517,6 +521,7 @@ int mt76_register_phy(struct mt76_phy *phy, bool vht,
 		      struct ieee80211_rate *rates, int n_rates)
 {
 	int ret;
+	const char *trigger;
 
 	ret = mt76_phy_init(phy, phy->hw);
 	if (ret)
@@ -540,8 +545,10 @@ int mt76_register_phy(struct mt76_phy *phy, bool vht,
 			return ret;
 	}
 
+	trigger = mt76_create_tpt_led_trigger(phy->hw);
+
 	if (IS_ENABLED(CONFIG_MT76_LEDS)) {
-		ret = mt76_led_init(phy);
+		ret = mt76_led_init(phy, trigger);
 		if (ret)
 			return ret;
 	}
@@ -701,6 +708,7 @@ int mt76_register_device(struct mt76_dev *dev, bool vht,
 	struct ieee80211_hw *hw = dev->hw;
 	struct mt76_phy *phy = &dev->phy;
 	int ret;
+	const char *trigger;
 
 	dev_set_drvdata(dev->dev, dev);
 	mt76_wcid_init(&dev->global_wcid);
@@ -731,8 +739,10 @@ int mt76_register_device(struct mt76_dev *dev, bool vht,
 	mt76_check_sband(&dev->phy, &phy->sband_5g, NL80211_BAND_5GHZ);
 	mt76_check_sband(&dev->phy, &phy->sband_6g, NL80211_BAND_6GHZ);
 
+	trigger = mt76_create_tpt_led_trigger(hw);
+
 	if (IS_ENABLED(CONFIG_MT76_LEDS)) {
-		ret = mt76_led_init(phy);
+		ret = mt76_led_init(phy, trigger);
 		if (ret)
 			return ret;
 	}
-- 
2.43.0


